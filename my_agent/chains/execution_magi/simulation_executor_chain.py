from typing import Dict, Any, Optional, List
from datetime import datetime
from pydantic import BaseModel, Field, field_validator
from langgraph.types import Command

from my_agent.utils.state import AgentState

class SimulationOutput(BaseModel):
    """Output from a simulation execution."""
    result_summary: str = Field(..., description="A summary of the simulation results.")
    dataset: List[Dict[str, Any]] = Field(
        default_factory=list,
        description="The dataset generated by the simulation, typically time-series data."
    )
    parameters: Dict[str, Any] = Field(
        default_factory=dict,
        description="Parameters used for the simulation."
    )


class ExecutionResult(BaseModel):
    """Result of code execution."""
    success: bool = Field(..., description="Whether the execution was successful.")
    execution_log: str = Field(..., description="Log of the execution process.")
    simulation_output: Optional[SimulationOutput] = Field(
        None,
        description="The output of the simulation, if successful."
    )
    error: Optional[str] = Field(
        None,
        description="Error message if the execution failed."
    )


class SimulationExecutorChain:
    """
    Chain for executing simulation code in a sandboxed environment.
    Currently simulates execution for demonstration purposes.
    """
    
    def __init__(self):
        """Initialize the SimulationExecutorChain."""
        pass
    
    async def __call__(self, state: AgentState) -> Command:
        """
        Execute the simulation code from the state.
        
        Args:
            state: The current agent state
            
        Returns:
            Command: The next command to execute in the graph
        """
        print("--- [Chain] Execution MAGI: 4. Executing Simulation ---")
        
        code_to_run = state.get("generated_code", "")
        
        try:
            # Execute the simulation
            result = await self.run(code_to_run)
            
            if result.success and result.simulation_output:
                print(f"  > Simulation completed successfully at {datetime.now().isoformat()}")
                return Command(
                    update={
                        "execution_log": result.execution_log,
                        "simulation_output": result.simulation_output.model_dump(),
                        "messages": [{"role": "system", "content": "Simulation executed successfully."}]
                    }
                )
            else:
                error_msg = f"Simulation failed: {result.error or 'Unknown error'}"
                print(f"  > {error_msg}")
                return Command(
                    update={
                        "execution_log": result.execution_log,
                        "error": error_msg,
                        "messages": [{"role": "system", "content": error_msg}]
                    }
                )
                
        except Exception as e:
            error_msg = f"Error during simulation execution: {str(e)}"
            print(f"  > {error_msg}")
            return Command(
                update={
                    "execution_log": f"Execution failed: {str(e)}",
                    "error": error_msg,
                    "messages": [{"role": "system", "content": error_msg}]
                }
            )
    
    async def run(self, code: str) -> ExecutionResult:
        """
        Execute the provided code and return the results.
        
        Args:
            code: The code to execute
            
        Returns:
            ExecutionResult: The result of the execution
        """
        if not code or "# Failed" in code:
            return ExecutionResult(
                success=False,
                execution_log="Execution skipped due to invalid or empty code.",
                error="Invalid or empty code provided."
            )
        
        try:
            print("  > Simulating code execution...")
            
            # Simulate execution delay
            import asyncio
            await asyncio.sleep(1)  # Simulate processing time
            
            # Generate dummy output
            output = SimulationOutput(
                result_summary="Simulation completed successfully.",
                dataset=[
                    {"time": 0, "value": 1.0},
                    {"time": 1, "value": 2.7},
                    {"time": 2, "value": 7.3},
                    {"time": 3, "value": 20.0},
                ],
                parameters={
                    "initial_condition": "A",
                    "iterations": 1000
                }
            )
            
            print("  > Execution simulation finished.")
            
            return ExecutionResult(
                success=True,
                execution_log=f"Execution successful at {datetime.now().isoformat()}",
                simulation_output=output
            )
            
        except Exception as e:
            return ExecutionResult(
                success=False,
                execution_log=f"Execution failed with error: {str(e)}",
                error=str(e)
            )


# Create a singleton instance
simulation_executor_chain_instance = SimulationExecutorChain()


async def simulation_executor_chain(state: AgentState) -> Command:
    """
    Entry point for the simulation executor chain.
    
    Args:
        state: The current agent state
        
    Returns:
        Command: The next command to execute in the graph
    """
    return await simulation_executor_chain_instance(state)
